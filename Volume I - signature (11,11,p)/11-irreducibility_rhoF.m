/*
    We check that the mod p representation associated with F is absolutely irreducible (except for the case p = 11)
*/

load "11-fieldK.m";
load "11-curveF.m";


print "\nThe field K is generated by w with minimal polynomial:";
print MinimalPolynomial(w);

print "\nThe unit group of K is:";
print U;
print "and is generated by {-1, eps1, eps2, eps3, eps4} where";
print "eps1 =", K!phi(U.2);
print "eps2 =", K!phi(U.3);
print "eps3 =", K!phi(U.4);
print "eps4 =", K!phi(U.5);
print "";

// list of possible signatures



S:= {
    [ 0, 0, 0, 0, 12 ],
    [ 0, 0, 0, 12, 0 ],
    [ 0, 0, 0, 12, 12 ],
    [ 0, 0, 12, 0, 0 ],
    [ 0, 0, 12, 0, 12 ],
    [ 0, 0, 12, 12, 0 ],
    [ 0, 0, 12, 12, 12 ],
    [ 0, 12, 0, 0, 0 ],
    [ 0, 12, 0, 0, 12 ],
    [ 0, 12, 0, 12, 0 ],
    [ 0, 12, 0, 12, 12 ],
    [ 0, 12, 12, 0, 0 ],
    [ 0, 12, 12, 0, 12 ],
    [ 0, 12, 12, 12, 0 ],
    [ 0, 12, 12, 12, 12 ],
    [ 12, 0, 0, 0, 0 ],
    [ 12, 0, 0, 0, 12 ],
    [ 12, 0, 0, 12, 0 ],
    [ 12, 0, 0, 12, 12 ],
    [ 12, 0, 12, 0, 0 ],
    [ 12, 0, 12, 0, 12 ],
    [ 12, 0, 12, 12, 0 ],
    [ 12, 0, 12, 12, 12 ],
    [ 12, 12, 0, 0, 0 ],
    [ 12, 12, 0, 0, 12 ],
    [ 12, 12, 0, 12, 0 ],
    [ 12, 12, 0, 12, 12 ],
    [ 12, 12, 12, 0, 0 ],
    [ 12, 12, 12, 0, 12 ],
    [ 12, 12, 12, 12, 0 ]
};

// This function computes the twisted norm associated to a given signatures as in Freitas-Siksek's paper
function TwistedNorm(a,s);
    N:=1;
    i:=1;
    for g in G do
        N:=N*g(a)^s[i];
        i:= i + 1;
    end for;
    return N;
end function;

// This function computes the number A_s that appears in Theorem 1 of Freitas-Siksek
function As(s);
    A:=(TwistedNorm(K!phi(U.2),s) - 1)*OK;
    for i in [3..5] do
        eps:=K!phi(U.i);
        A:=Gcd(A,(TwistedNorm(K!phi(U.i),s) - 1)*OK);
    end for;
    return Norm(A);
end function;



B:=Lcm([As(s) : s in S]);

print "\nThe integer B for the number field K from Theorem 1 in [Freitas-Siksek] (JTNB, 2015) is:";
print B;
print "\nThis rules the case p > 19.";


print "\nWe now deal with p = 5, 7, 11, 17 and 19.\n";
for N in [20,14,11,17,19] do
    print "\n************* N =",N,"*************\n";
    X:=SmallModularCurve(N,K); 
    assert Genus(X) eq 1;
    print "The modular curve X_0(N) is:",X;
    print "\nWe check it has rank 0...";
    //SetClassGroupBounds("GRH"); // To speed up the computation of the rank. Comment it for an unconditional output.
    assert Rank(X) eq 0;
    print "...done!";
    print "++++++++++++++++++++++", Realhours();

    T, TtoX:=TorsionSubgroup(X);
    print "Its torsion subgroup is:",T;
    j := jInvariant(X);
    print "For each torsion point, we compute its j-invariant:";
    for n in [0..#T-1] do
        P:=n * TtoX(T.1);
        print P, Evaluate(j,P);
    end for;
end for;


Listj:=[ 16581375, -3375, -32768, -121, -24729001, -882216989/131072, -297756989/2, -884736];


print "\nNext we show that there is no a,b in Z such that j(F_{a,b}^{(delta)}) = j(F_{a,b}) = j0 with j0 in ",Listj;
print "\nWe do it by checking that there is no degree 1 factor in the factorization of the numerator of j(F_{a,b}) - j0";
print "\nWe display below the degrees of such irreducible factors:\n";


P<a,b>:=RationalFunctionField(K,2);
jF:=jInvariant(FreyF(a,b,1));
nF:=Numerator(jF);
dF:=Denominator(jF);

for j0 in Listj do
    fact:=Factorization(nF -j0*dF);
    print "For j0 =",j0,"we have:", [Degree(fact[i,1]) : i in [1..#fact]];
end for;
print "\nThis rules out the cases where p = 5, 7, 11, 17 and 19.\n";



print "We finally deal with the last remaining case p = 13.";
X:=SmallModularCurve(26,K);

cusps:=[CuspPlaces(X,26,d) : d in {1,2,13,26}];
print "\nThere modular curve X_0(26) has genus",Genus(X);
print "\nIt has the following",#cusps,"cusps:";
print cusps;

w2:=AtkinLehnerInvolution(X,26,2);
G2:=AutomorphismGroup(X,[w2]);
E,psi:=CurveQuotient(G2);
print "\nThe quotient of the modular curve X_0(26) by the Atkin-Lehner involution w_2 is the",E;
T, TtoE := TorsionSubgroup(E);
assert #TorsionSubgroup(E) eq 3;
print "\nThe torsion subgroup of E/K has order 3.";
print "\nWe check that E/K has rank 0...";
//SetClassGroupBounds("GRH"); // To speed up the computation of the rank. Comment it for an unconditional output.
assert Rank(E) eq 0;
print "...done!";
print "++++++++++++++++++++++", Realhours();


print "\nWe compute the inverse images of each of the three K-rational points on E under the map X -> E.";

P1:=TtoE(T.1);
Y1:=P1@@psi;
Y1K:=ChangeRing(Y1,K);
Points(Y1K);

P2:=TtoE(2*T.1);
Y2:=P2@@psi;
Y2K:=ChangeRing(Y2,K);
Points(Y2K);

P3:=TtoE(3*T.1);
Y3:=P3@@psi;
Y3K:=ChangeRing(Y3,K);
Points(Y3K);

print "\nThey correspond to the four 4 cusps on X.";

print "++++++++++++++++++++++", Realhours();
